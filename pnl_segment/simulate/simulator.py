import os
import pathlib
import random
import tempfile
from collections import defaultdict
from datetime import datetime

import numpy as np
from tqdm import tqdm

from pnl_segment.point_cloud.ref_space import RefSpace
from .effect import EffectDm
from .mask import Mask


def run_multi(fnc):
    """ decorator, allows fnc to be called multiple times in parallel
    """

    def fnc_multi(self, n=1, verbose=False, **kwargs):
        res_list = list()
        tqdm_dict = {'desc': fnc.__name__,
                     'disable': not verbose,
                     'total': n}
        for _ in tqdm(range(n), **tqdm_dict):
            res_list.append(fnc(self, verbose=verbose, **kwargs))

        if n > 1:
            return res_list
        else:
            return res_list[0]

    return fnc_multi


class Simulator:
    """ generates an effect, and applies it to random healthy, outputs nii

    a healthy img is generated by sampling the given healthy population.
    an effect img is generated by adding some constant vector to same mask of a
    healthy image (see effect.py)

    Attributes:
        f_img_health (dict): first keys are sbj, second keys are names of feat,
                           leafs are names of files which contain img of
                           sbj's feat (all assumed in registered space)
    """

    def __init__(self, f_img_health, split_ratio=.5, mask_dilate=5):
        self.f_img_health = f_img_health
        self.split_ratio = split_ratio
        self.mask_dilate = mask_dilate

        # check ref spaces, store a copy
        ref_list = [RefSpace.from_nii(f) for f in self.iter_img()]
        for r in ref_list[1:]:
            if ref_list[0] != r:
                raise AttributeError('inconsistent reference space')
        self.ref_space = ref_list[0]

    def iter_img(self, feat_iter=None, sbj_iter=None):
        """ iterates over all healthy img"""
        if feat_iter is None:
            sbj = next(iter(self.f_img_health.keys()))
            feat_iter = sorted(self.f_img_health[sbj])

        if sbj_iter is None:
            sbj_iter = self.f_img_health.keys()

        for feat in feat_iter:
            for sbj in sbj_iter:
                yield self.f_img_health[sbj][feat]

    def sample_eff(self, effect, folder=None, sym_link_health=True,
                   label='{sbj}_{feat}_{eff_label}.nii.gz', reseed=True,
                   mask_to_nii=True):
        """ adds effect to split_ratio (without replacement) of healthy img

        Args:
            effect (Effect): applies effect to img set
            folder (str or Path): path to stored effect files
            sym_link_health (bool): if True, healthy img are sym linked (makes
                                    for clean folder structure)
            label (str): name of effect files to produce
            reseed (bool): reseed random generator via timestamp before split
            mask_to_nii (bool): toggles saving effect mask to folder

        Returns:
            f_img_dict (dict): keys are grp labels, values are iter, each
                               element of the iter is a list of img from a sbj
                               this is confusing, here's an example:
                               {'eff': [['sbj1_FA.nii.gz', 'sbj1_MD.nii.gz'], \
                                        ['sbj2_FA.nii.gz', 'sbj2_MD.nii.gz']],
                                'healthy': ... }
        """

        # if no folder passed, put new effect img in a temp directory
        if folder is None:
            folder = tempfile.TemporaryDirectory().name
            folder = pathlib.Path(folder)
            folder.mkdir()

        def get_f_nii_out(sbj, eff_label):
            # find locations for output files
            f_nii_dict_out = dict()
            for feat in effect.feat_label:
                _label = label.format(sbj=sbj, feat=feat, eff_label=eff_label)
                f_nii_dict_out[feat] = folder / _label

            # sorted in same order as effect.feat_label
            img_list = [f_nii_dict_out[feat] for feat in effect.feat_label]

            return f_nii_dict_out, img_list

        # compute n_effect
        n_sbj = len(self.f_img_health.keys())
        n_effect = np.ceil(self.split_ratio * n_sbj).astype(int)

        # split sbj into health and effect groups
        if reseed:
            # ensure
            random.seed(datetime.now())
        sbj_all = set(self.f_img_health.keys())
        sbj_effect = random.sample(sbj_all, k=n_effect)
        sbj_health = sbj_all - set(sbj_effect)

        # init f_img_dict with healthies
        f_img_dict = defaultdict(list)
        for sbj in sbj_health:
            img_list = [self.f_img_health[sbj][f] for f in effect.feat_label]
            if sym_link_health:
                # build sym links, replace img_list with these sym_links
                _, img_list_sym = get_f_nii_out(sbj, eff_label='healthy')
                for f, f_sym in zip(img_list, img_list_sym):
                    os.symlink(f, f_sym)
                img_list = img_list_sym
            f_img_dict['healthy'].append(img_list)

        # add sbj_effect to f_img_dict
        for sbj in sbj_effect:
            f_nii_dict_out, img_list = get_f_nii_out(sbj, eff_label='effect')

            # apply effect
            effect.apply_from_to_nii(f_nii_dict=self.f_img_health[sbj],
                                     f_nii_dict_out=f_nii_dict_out)

            f_img_dict[effect].append(img_list)

        if mask_to_nii:
            effect.mask.to_nii(f_out=folder / 'mask.nii.gz',
                               f_ref=next(self.iter_img()))

        return f_img_dict, folder

    def _run(self, f_img_dict, part_graph_factory, f_mask=None, verbose=False,
             **kwargs):
        """ runs experiment
        """

        # build mask as intersection of all img, save to file
        if f_mask is None:
            mask = Mask.build_intersection_from_nii(self.iter_img(),
                                                    thresh=.95)
            f_mask = mask.to_nii()

        # build part graph
        part_graph = part_graph_factory(f_img_dict=f_img_dict, history=True,
                                        f_mask=f_mask, verbose=verbose,
                                        **kwargs)

        # reduce
        part_graph.reduce_to(1, verbose=verbose)

        # build segmentation
        def spanning_fnc(reg):
            return reg.obj

        part_graph_span = part_graph.get_min_spanning_region(spanning_fnc)

        return part_graph_span, part_graph

    @run_multi
    def run_healthy(self, **kwargs):
        # build feat_label
        sbj = next(iter(self.f_img_health.keys()))
        feat_label = sorted(self.f_img_health[sbj].keys())

        # build dummy effect
        effect_dm = EffectDm(feat_label=feat_label)

        # apply 'effect' to some subset of images
        f_img_dict, folder = self.sample_eff(effect_dm)
        return self._run(f_img_dict, **kwargs), folder

    @run_multi
    def run_effect(self, *, effect, **kwargs):
        f_img_dict, folder = self.sample_eff(effect)
        return self._run(f_img_dict, **kwargs), folder

    def compute_auc(self, f_img_dict, f_segment_nii, mask_sep):
        """ computes auc """
        pass
