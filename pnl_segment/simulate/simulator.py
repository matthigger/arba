import numpy as np
from scipy.ndimage import binary_dilation

from pnl_segment.simulate.effect import Effect


class Simulator:
    """ generates an effect, and applies it to random healthy, outputs nii

    a healthy img is generated by sampling the given healthy population and
    adding some noise (or not).  an effect img is generated by adding some
    noise to a subset of a healthy image (see effect.py)

    Attributes:
        f_img_tree (dict): first keys are sbj, second keys are names of feat,
                           leaves are names of files which contain img of
                           sbj's feat (all assumed in registered space)
        eff_center_prior (np.array): acts as weighted mask of ijk center of eff
        eff_mean (np.array): mean of effect
        eff_cov (np.array): covariance of effect
        eff_rad (int): radius of effect
        eff_n (int): number of effect locations

    """

    def __init__(self, f_img_tree, eff_center_prior, eff_mean, eff_cov,
                 eff_rad, eff_n=1):
        self.f_img_tree = f_img_tree
        self._eff_center_prior = eff_center_prior
        self._p = eff_center_prior.flatten()
        self._p *= 1 / sum(self._p)
        self.eff_mean = eff_mean
        self.eff_cov = eff_cov
        self.eff_rad = eff_rad
        self.eff_n = eff_n

    @property
    def eff_center_prior(self):
        return self._eff_center_prior

    @property
    def sbj_list(self):
        self.list(self.f_img_tree.keys())

    def sample_eff_mask(self):
        """ samples effect location

        Returns:
            eff_mask (np.array): array of 1s where effect is present

        >>> np.random.seed(1)
        >>> s = Simulator(eff_center_prior=np.ones((9, 9)),
        ...               eff_rad=0,
        ...               eff_n=6,
        ...               eff_mean=None,
        ...               eff_cov=None,
        ...               f_img_tree=None)
        >>> s.sample_eff_mask()
        array([[1, 0, 0, 0, 0, 0, 0, 1, 0],
               [0, 0, 1, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 1, 0, 0],
               [0, 0, 0, 0, 0, 0, 1, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 1, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0]])
        >>> s.eff_rad = 1
        >>> s.eff_n = 2
        >>> s.sample_eff_mask()
        array([[0, 0, 0, 0, 0, 0, 1, 0, 0],
               [0, 0, 0, 0, 0, 1, 1, 1, 0],
               [1, 0, 0, 0, 0, 0, 1, 0, 0],
               [1, 1, 0, 0, 0, 0, 0, 0, 0],
               [1, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0],
               [0, 0, 0, 0, 0, 0, 0, 0, 0]])
        """
        # choose idx via p (idx is linear idx)
        idx = np.random.choice(range(len(self._p)), size=self.eff_n, p=self._p)

        # build mask of effect center
        shape = self._eff_center_prior.shape
        eff_mask = np.zeros(shape)
        for _idx in idx:
            eff_mask[np.unravel_index(_idx, shape)] = 1

        if self.eff_rad:
            eff_mask = binary_dilation(eff_mask,
                                       iterations=self.eff_rad,
                                       mask=self.eff_center_prior)
        return eff_mask.astype(int)

    def sample_img_eff(self, effect=False):
        # get random sbj
        sbj = np.random.choice(self.sbj_list)
        x = self.get_x(sbj)

        if effect:
            e = Effect(mask=self.sample_eff_mask(),
                       mean=self.eff_mean,
                       cov=self.eff_cov)
            x = e.apply(x)
        return x

    def get_x(self, sbj):
        """ returns array associated with sbj
        """
        pass
